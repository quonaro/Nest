# Nestfile Example
# This is a comprehensive example configuration file for Nest.
# Copy this file to 'nestfile' in your project root and customize it.
#
# This example demonstrates:
# - Positional and named arguments
# - Parameter types (str, bool, num, arr)
# - Environment variables (direct assignment and .env files)
# - Template variables ({{param}}, {{now}}, {{user}})
# - Working directory configuration
# - Nested command groups
# - Single-line and multiline scripts
# - Include directives for modular configuration

# ============================================================================
# VARIABLES AND CONSTANTS
# ============================================================================
#
# Variables (@var) can be redefined, constants (@const) cannot.
# Both can be used in templates with {{NAME}} syntax.
#
# Variables are useful for values that might change:
@var APP_NAME = "myapp"
@var VERSION = "1.0.0"
@var NODE_ENV = "development"

# Constants are useful for values that should never change:
@const COMPANY_NAME = "My Company"
@const LICENSE = "MIT"

# Variables can be redefined (last definition wins):
@var NODE_ENV = "production"  # This overrides the previous definition

# Constants cannot be redefined (will cause an error):
# @const COMPANY_NAME = "Other Company"  # ERROR: Cannot redefine constant

# Variables and constants can also be defined inside commands (local scope)
# Local variables/constants override global ones for that specific command
test_local():
    > desc: Example with local variables and constants
    # Local variable overrides global
    @var APP_NAME = "local-app"
    # Local constant overrides global
    @const COMPANY_NAME = "Local Company"
    # New local variable (only available in this command)
    @var LOCAL_VAR = "local-value"
    > script: |
        echo "App: {{APP_NAME}} (local overrides global)"
        echo "Company: {{COMPANY_NAME}} (local constant overrides global)"
        echo "Local: {{LOCAL_VAR}}"

# ============================================================================
# FUNCTIONS
# ============================================================================
#
# Functions allow you to create reusable scripts that can be called from
# commands or other functions. Functions are defined at the global level.
#
# Functions can:
# - Execute commands
# - Call other functions
# - Use variables, constants, and environment variables (from global definitions)
# - Use system environment variables
# - Have parameters
# - Define local variables
#
# Example: Simple function
@function hello(name: str):
    echo "Hello {{name}}!"

# Example: Function with local variables
@function setup_env(env_name: str):
    @var LOCAL_ENV = "{{env_name}}"
    echo "Setting up environment: {{LOCAL_ENV}}"
    echo "App: {{APP_NAME}} v{{VERSION}}"

# Example: Function calling another function
@function build_app(target: str):
    echo "Building for target: {{target}}"
    setup_env(env_name="{{target}}")
    npm run build --target={{target}}

# Example: Function using commands
@function deploy_app(version: str):
    echo "Deploying version {{version}}"
    # Functions can call commands
    build(target="{{version}}")
    echo "Deployment complete"

# Example: Command using functions
test_functions():
    > desc: Example command using functions
    > script: |
        hello(name="World")
        setup_env(env_name="test")
        build_app(target="x86_64")

# ============================================================================
# COMMAND DEPENDENCIES
# ============================================================================
#
# Commands can depend on other commands using > depends: directive.
# Dependencies are executed before the main command.
#
# Example: Build pipeline with dependencies
clean():
    > desc: Clean build artifacts
    > script: |
        echo "Cleaning build artifacts..."
        rm -rf build/ dist/ node_modules/.cache/

build():
    > desc: Build the project
    > depends: clean
    > script: |
        echo "Building project..."
        npm run build

test():
    > desc: Run tests
    > depends: build
    > script: |
        echo "Running tests..."
        npm test

deploy():
    > desc: Deploy application
    > depends: build, test
    > script: |
        echo "Deploying application..."
        # npm run deploy

# Multiple dependencies (comma-separated)
release():
    > desc: Create release
    > depends: clean, build, test
    > script: |
        echo "Creating release..."
        # git tag -a "v{{version}}" -m "Release {{version}}"

# Nested commands in dependencies
# Use colon (:) separator for absolute paths from root
deploy_full():
    > desc: Full deployment with nested command dependencies
    > depends: clean, dev:lint, dev:test, docker:build
    > script: |
        echo "Deploying with all checks..."
        # Full deployment process

# Example: Using nested commands from different groups
# Absolute path syntax: "group:command"
ci():
    > desc: Continuous integration pipeline
    > depends: clean, dev:lint, dev:test, docker:build
    > script: |
        echo "Running CI pipeline..."
        # CI/CD commands here

# Relative dependencies in nested commands
# When inside a nested command, dependencies without ':' are relative to parent group
# To reference top-level commands from nested commands, use absolute paths
dev:
    > desc: Development tools

    prepare():
        > desc: Prepare development environment
        > script: |
            echo "Preparing dev environment..."

    build():
        > desc: Build in dev mode
        > depends: prepare  # Relative: resolves to dev:prepare (same group)
        > script: |
            echo "Building in dev mode..."

    deploy():
        > desc: Deploy dev version
        # Note: dependencies without ':' are always relative to parent group
        # To use top-level 'clean', you need to create dev:clean or use absolute path
        > depends: build  # Relative: resolves to dev:build
        > script: |
            echo "Deploying dev version..."

    full():
        > desc: Full dev workflow
        > depends: lint, test, build  # All relative: dev:lint, dev:test, dev:build
        > script: |
            echo "Running full dev workflow..."

# Mixing absolute and relative paths
production_deploy():
    > desc: Production deployment
    > depends: clean, dev:test, docker:build, docker:run
    > script: |
        echo "Deploying to production..."

# Dependencies with arguments
# You can pass arguments to dependency commands using function-like syntax
# Syntax: command(arg1="value1", arg2=true, arg3=123)
build_custom(!target|t: str = "x86_64", !release|r: bool = false):
    > desc: Build with target and release options
    > script: |
        echo "Building for {{target}} (release={{release}})..."

test_custom(!coverage|c: bool = false):
    > desc: Run tests with optional coverage
    > script: |
        if [ "{{coverage}}" = "true" ]; then
            echo "Running tests with coverage..."
        else
            echo "Running tests..."
        fi

# Example: Using dependencies with arguments
deploy_with_args():
    > desc: Deploy with specific build configuration
    # Pass arguments to dependencies: build_custom(target="arm64", release=true)
    > depends: build_custom(target="arm64", release=true), test_custom(coverage=true)
    > script: |
        echo "Deploying with custom build configuration..."

# Example: Mixing dependencies with and without arguments
release_full():
    > desc: Full release with custom configurations
    # Some dependencies have arguments, others don't
    > depends: clean, build_custom(target="x86_64", release=true), test_custom(coverage=true)
    > script: |
        echo "Creating full release..."

# Example: Nested commands with arguments in dependencies
docker:
    > desc: Docker operations

    build(!tag|t: str = "latest"):
        > desc: Build Docker image
        > env: DOCKER_BUILDKIT=1
        > script: |
            echo "Building Docker image with tag {{tag}}"
            # docker build -t myapp:{{tag}} .

    deploy():
        > desc: Deploy Docker container
        # Using relative dependency with arguments: build resolves to docker:build
        > depends: build(tag="production")
        > script: |
            echo "Deploying Docker container..."
            # docker push myapp:production

# Example: Top-level command using nested command with arguments
production_docker():
    > desc: Production Docker deployment
    # Using absolute path with arguments: docker:build(tag="v1.0.0")
    > depends: docker:build(tag="v1.0.0"), docker:deploy
    > script: |
        echo "Production Docker deployment complete..."

# ============================================================================
# PARAMETER VALIDATION
# ============================================================================
#
# You can validate command parameters using regex patterns.
# Format: > validate: param_name matches /regex_pattern/
#
# Example: Version validation
deploy(version: str):
    > desc: Deploy with version validation
    > validate: version matches /^v?\d+\.\d+\.\d+$/
    > script: |
        echo "Deploying version {{version}}"
        # ./deploy.sh {{version}}

# Example: Email validation
register(email: str, username: str):
    > desc: Register user with validation
    > validate: email matches /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
    > validate: username matches /^[a-zA-Z0-9_]{3,20}$/
    > script: |
        echo "Registering {{username}} with email {{email}}"
        # Registration logic

# Example: Case-insensitive validation
create_tag(name: str):
    > desc: Create tag with case-insensitive validation
    > validate: name matches /^[a-z]+$/i
    > script: |
        echo "Creating tag {{name}}"
        # git tag {{name}}

# Example: URL validation
open_url(url: str):
    > desc: Open URL with validation
    > validate: url matches /^https?:\/\/.+\..+/
    > script: |
        echo "Opening {{url}}"
        # xdg-open {{url}}

# ============================================================================
# BEFORE, AFTER, AND FALLBACK SCRIPTS
# ============================================================================
#
# You can define scripts that run before, after, or as a fallback for the main script.
# All support multiline syntax with |.
#
# Example: Deployment with hooks and error handling
deploy_with_hooks():
    > desc: Deploy with before/after hooks and error handling
    > before: |
        echo "Setting up deployment environment..."
        # Pre-deployment checks
        echo "Environment ready"
    > script: |
        echo "Deploying application..."
        # Main deployment logic
        # If this fails, fallback will execute
    > after: |
        echo "Deployment completed successfully"
        # Post-deployment tasks (only if main script succeeds)
        echo "Sending notification..."
    > fallback: |
        echo "Deployment failed, rolling back..."
        # Error handling (only if main script fails)
        # This replaces the error output
        echo "Rollback complete"

# Example: Build with cleanup
build_with_cleanup():
    > desc: Build with before setup and after cleanup
    > before: |
        echo "Cleaning previous build..."
        rm -rf dist/ build/
    > script: |
        echo "Building project..."
        npm run build
    > after: |
        echo "Build completed!"
        echo "Build artifacts:"
        ls -la dist/

# Example: Test with fallback
test_with_fallback():
    > desc: Run tests with error handling
    > before: echo "Running tests..."
    > script: |
        npm test
        # If tests fail, fallback will execute
    > fallback: |
        echo "Tests failed, but continuing..."
        echo "Generating test report..."
        # Error handling instead of showing error

# ============================================================================
# INCLUDE DIRECTIVES
# ============================================================================
#
# Include directives allow you to include commands from other files or directories.
# This enables modular configuration and code reuse.
#
# Three types of includes are supported:
#
# 1. Specific file:
#    @include app1/nestfile
#    This includes a specific configuration file.
#
# 2. Pattern with wildcard:
#    @include app2/*.nest
#    This includes all files matching the pattern (e.g., all .nest files in app2/).
#
# 3. Directory:
#    @include app3/
#    This includes all configuration files (nestfile, Nestfile, nest, Nest) from the directory.
#
# Note: Include directives are processed before parsing, so included commands
# are merged into the main configuration. Circular includes are detected and
# will cause an error.
#
# Example includes (uncomment to use):
# @include apps/common.nest
# @include modules/*.nest
# @include commands/

# ============================================================================
# BASIC COMMANDS
# ============================================================================

# Simple command with positional arguments
greet(name: str, message: str):
    > desc: Greet someone with a message
    > script: |
        echo "Hello {{name}}, {{message}}!"

# Command with named arguments and defaults
# Using variables and constants in the script
build(!target|t: str = "x86_64", !release|r: bool = false):
    > desc: Build the project
    > script: |
        echo "Building {{APP_NAME}} v{{VERSION}} for {{target}}"
        echo "Company: {{COMPANY_NAME}}"
        if [ "{{release}}" = "true" ]; then
            echo "Release mode enabled"
        else
            echo "Debug mode"
        fi

# Command with mixed positional and named arguments
copy(source: str, !destination|d: str, !overwrite|o: bool = false):
    > desc: Copy a file
    > script: |
        if [ "{{overwrite}}" = "true" ]; then
            echo "Copying {{source}} to {{destination}} (with overwrite)"
        else
            echo "Copying {{source}} to {{destination}}"
        fi

# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================

# Command with direct environment variable assignment
run_app(!port|p: num = 3000):
    > desc: Run application with environment variables
    > env: NODE_ENV=production
    > env: PORT={{port}}
    > script: |
        echo "Starting app on port $PORT"
        echo "Environment: $NODE_ENV"
        # Your app startup command here
        # node server.js

# Command loading environment from .env file
# Note: The .env file should exist in your project root
# Example .env file content:
#   DATABASE_URL=postgres://localhost/mydb
#   API_KEY=secret123
start_db():
    > desc: Start database with environment from .env file
    > env: .env
    > script: |
        echo "Database URL: $DATABASE_URL"
        echo "API Key: $API_KEY"
        # Your database startup command here

# Command with multiple environment variables
deploy_app(version: str, !env|e: str = "production"):
    > desc: Deploy application with environment configuration
    > env: DEPLOY_ENV={{env}}
    > env: APP_VERSION={{version}}
    > env: DEPLOYER={{user}}
    > env: BUILD_TIME={{now}}
    > script: |
        echo "Deploying {{version}} to {{env}}"
        echo "Deployed by: $DEPLOYER"
        echo "Build time: $BUILD_TIME"
        # Your deployment command here

# Command combining .env file and direct assignments
# Direct assignments override values from .env file
run_dev():
    > desc: Run development server with custom env
    > env: .env.local
    > env: NODE_ENV=development
    > env: DEBUG=true
    > script: |
        echo "Running in $NODE_ENV mode"
        echo "Debug: $DEBUG"
        # Your dev server command here

# Command using system environment variables with fallback
# Syntax: ${VAR:-default} - uses system VAR if exists, otherwise uses default
build():
    > desc: Build with system environment variables
    > env: NODE_ENV=${NODE_ENV:-development}  # Uses system NODE_ENV or defaults to "development"
    > env: BUILD_NUMBER=${CI_BUILD_NUMBER:-local}  # Uses CI build number or "local"
    > script: |
        echo "Building in $NODE_ENV mode"
        echo "Build number: $BUILD_NUMBER"
        # npm run build

# Command using system variables without fallback
# Syntax: ${VAR} - uses system VAR if exists, otherwise empty string
deploy():
    > desc: Deploy using system environment variables
    > env: DATABASE_URL=${DATABASE_URL}  # Uses system DATABASE_URL if set
    > env: API_KEY=${API_KEY}  # Uses system API_KEY if set
    > script: |
        if [ -z "$DATABASE_URL" ]; then
            echo "Error: DATABASE_URL not set"
            exit 1
        fi
        echo "Deploying with database: $DATABASE_URL"
        # ./deploy.sh

# ============================================================================
# TEMPLATE VARIABLES
# ============================================================================

# Using special template variables: {{now}} and {{user}}
create_backup(name: str):
    > desc: Create backup with timestamp and user info
    > script: |
        echo "Creating backup: {{name}}"
        echo "Created by: {{user}}"
        echo "Created at: {{now}}"
        # Your backup command here
        # tar -czf "backup-{{name}}-{{now}}.tar.gz" ./data

# Command using template variables in environment
log_action(action: str):
    > desc: Log action with user and timestamp
    > env: LOG_USER={{user}}
    > env: LOG_TIME={{now}}
    > script: |
        echo "Action: {{action}}"
        echo "User: $LOG_USER"
        echo "Time: $LOG_TIME"
        # Your logging command here

# ============================================================================
# WORKING DIRECTORY
# ============================================================================

# Command with custom working directory
test():
    > desc: Run tests in specific directory
    > cwd: ./tests
    > script: |
        echo "Running tests in $(pwd)"
        # Your test command here
        # pytest

# Command combining cwd and env
build_frontend():
    > desc: Build frontend in specific directory
    > cwd: ./frontend
    > env: NODE_ENV=production
    > script: |
        echo "Building in $(pwd)"
        echo "Environment: $NODE_ENV"
        # Your build command here
        # npm run build

# ============================================================================
# PARAMETER TYPES
# ============================================================================

# Command with numeric parameter
scale(!replicas|r: num = 1):
    > desc: Scale application replicas
    > script: |
        echo "Scaling to {{replicas}} replicas"
        # Your scaling command here
        # kubectl scale deployment app --replicas={{replicas}}

# Command with array parameter
deploy(version: str, !retries|r: num = 3, !tags|t: arr = []):
    > desc: Deploy application with tags
    > env: APP_VERSION={{version}}
    > script: |
        echo "Deploying version {{version}}"
        echo "Retries: {{retries}}"
        if [ -n "{{tags}}" ]; then
            echo "Tags: {{tags}}"
        else
            echo "No tags specified"
        fi
        # Your deployment command here

# Command with boolean flag
clean(!force|f: bool = false):
    > desc: Clean build artifacts
    > script: |
        if [ "{{force}}" = "true" ]; then
            echo "Force cleaning..."
            # rm -rf ./build ./dist
        else
            echo "Cleaning..."
            # rm -rf ./build
        fi

# ============================================================================
# NESTED COMMANDS (GROUPS)
# ============================================================================

# Group command with subcommands
dev:
    > desc: Development tools

    default(!watch|w: bool = false):
        > desc: Start development server
        > env: NODE_ENV=development
        > script: |
            if [ "{{watch}}" = "true" ]; then
                echo "Starting dev server with watch mode"
                # nodemon src/index.js
            else
                echo "Starting dev server"
                # node src/index.js
            fi

    lint(!fix|f: bool = false):
        > desc: Run linter
        > script: |
            if [ "{{fix}}" = "true" ]; then
                echo "Running linter with --fix"
                # eslint src/ --fix
            else
                echo "Running linter"
                # eslint src/
            fi

    test(!coverage|c: bool = false):
        > desc: Run tests
        > env: NODE_ENV=test
        > script: |
            if [ "{{coverage}}" = "true" ]; then
                echo "Running tests with coverage"
                # npm test -- --coverage
            else
                echo "Running tests"
                # npm test
            fi

# Another group with environment configuration
docker:
    > desc: Docker operations

    build(!tag|t: str = "latest"):
        > desc: Build Docker image
        > env: DOCKER_BUILDKIT=1
        > script: |
            echo "Building Docker image with tag {{tag}}"
            # docker build -t myapp:{{tag}} .

    run(!port|p: num = 8080):
        > desc: Run Docker container
        > env: CONTAINER_PORT={{port}}
        > script: |
            echo "Running container on port {{port}}"
            # docker run -p {{port}}:8080 myapp:latest

    deploy():
        > desc: Deploy Docker container
        # Using relative dependency: build resolves to docker:build
        > depends: build
        > script: |
            echo "Deploying Docker container..."
            # docker push myapp:latest

# ============================================================================
# SINGLE-LINE SCRIPTS
# ============================================================================

# Single-line script (no pipe needed)
version():
    > desc: Show version information
    > script: echo "Nest CLI - Version 1.0.0"

# Single-line with template
hello(name: str):
    > desc: Simple greeting
    > script: echo "Hello, {{name}}!"

# ============================================================================
# CONDITIONAL EXECUTION (IF/ELIF/ELSE)
# ============================================================================

# Conditional execution allows you to execute different scripts based on conditions.
# You can use multiple if directives, followed by elif and else.
# Conditions support comparison operators (==, !=, <=, >=) and logical operators (&&, ||, !).

# Example: Deploy based on environment
deploy(env: str):
    > desc: Deploy to different environments with conditional logic
    > if: env == "production"
    > script: |
        echo "Deploying to PRODUCTION..."
        # Production deployment commands
    > if: env == "staging"
    > script: |
        echo "Deploying to STAGING..."
        # Staging deployment commands
    > elif: env == "development"
    > script: |
        echo "Deploying to DEVELOPMENT..."
        # Development deployment commands
    > else:
    > script: |
        echo "Unknown environment: {{env}}"
        exit 1

# Example: Conditional execution with logical operators
build(!target|t: str = "x86_64", !release|r: bool = false):
    > desc: Build with conditional logic using logical operators
    > if: target == "x86_64" && release == "true"
    > script: |
        echo "Building optimized x86_64 release..."
        cargo build --release --target x86_64-unknown-linux-gnu
    > elif: target == "arm64" || target == "aarch64"
    > script: |
        echo "Building for ARM64..."
        cargo build --target aarch64-unknown-linux-gnu
    > elif: !(target == "x86_64")
    > script: |
        echo "Building for {{target}}..."
        cargo build --target {{target}}
    > else:
    > script: |
        echo "Building default target..."
        cargo build

# Example: Numeric comparisons
scale(!replicas|r: num = 1):
    > desc: Scale application with numeric conditions
    > if: replicas <= 0
    > script: |
        echo "Error: Replicas must be greater than 0"
        exit 1
    > elif: replicas >= 10
    > script: |
        echo "Warning: Scaling to {{replicas}} replicas (high resource usage)"
        kubectl scale deployment app --replicas={{replicas}}
    > else:
    > script: |
        echo "Scaling to {{replicas}} replicas"
        kubectl scale deployment app --replicas={{replicas}}

# ============================================================================
# LOGGING DIRECTIVES
# ============================================================================

# Logging directives allow you to log command execution to files.
# Supported formats: json, txt

# Example: Log to JSON file
deploy_with_json_log(version: str):
    > desc: Deploy with JSON logging
    > logs:json ./logs/deploy-{{version}}.json
    > script: |
        echo "Deploying version {{version}}"
        # Deployment commands

# Example: Log to text file
build_with_txt_log():
    > desc: Build with text logging
    > logs:txt ./logs/build.log
    > script: |
        echo "Building project..."
        npm run build

# Example: Log with template variables in path
deploy_logged(env: str):
    > desc: Deploy with logging using template variables
    > logs:json ./logs/{{env}}/deploy-{{now}}.json
    > script: |
        echo "Deploying to {{env}}"
        # Deployment commands

# ============================================================================
# COMPLEX EXAMPLES
# ============================================================================

# Complex command combining all features
# Using variables, constants, parameters, and special variables
release(version: str, !dry-run|d: bool = false):
    > desc: Create a new release
    > env: RELEASE_VERSION={{version}}
    > env: RELEASED_BY={{user}}
    > env: RELEASE_TIME={{now}}
    > env: APP_NAME={{APP_NAME}}
    > cwd: .
    > logs:json ./logs/release-{{version}}.json
    > script: |
        echo "Creating release {{version}} for {{APP_NAME}}"
        echo "Company: {{COMPANY_NAME}}"
        echo "Released by: {{user}}"
        echo "Release time: {{now}}"
        if [ "{{dry-run}}" = "true" ]; then
            echo "DRY RUN: Would create release {{version}}"
        else
            echo "Creating release {{version}}..."
            # Your release commands here
            # git tag -a "v{{version}}" -m "Release {{version}}"
            # git push origin "v{{version}}"
        fi
